import { mockReportData } from "@/lib/mock-report-data";
import JSZip from "jszip";

async function fetchFileAsBuffer(url: string): Promise<Buffer | null> {
  try {
    const response = await fetch(url);
    if (!response.ok) return null;
    const blob = await response.blob();
    return Buffer.from(await blob.arrayBuffer());
  } catch (error) {
    console.error(`[v0] Failed to fetch ${url}:`, error);
    return null;
  }
}

export async function GET(
  request: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params;
    const report = mockReportData;
    const profileData = report.data.profile;
    const zip = new JSZip();

    // Create a simple text-based PDF placeholder (production should use actual PDF generation)
    const pdfContent = `
Employee Compliance Report
==========================

Employee: ${profileData.user_full_name}
Email: ${profileData.email}
Phone: ${profileData.phone}
Address: ${profileData.full_address}

Generated: ${new Date().toLocaleDateString()}
Generated By: ${report.data.employment_reviewed_by}

REPORT CONTAINS:
- Employment History
- References Verification
- Supporting Documents
- DBS Information
- Identity Verification Results

This report was generated on ${new Date().toLocaleString()}
    `.trim();

    zip.file(`${profileData.user_full_name}_Compliance_Report.txt`, pdfContent);

    // Add CV
    if (report.data.cv && report.data.cv.url) {
      const cvBuffer = await fetchFileAsBuffer(report.data.cv.url);
      if (cvBuffer) {
        zip.file(`documents/cv/${report.data.cv.file}`, cvBuffer);
      }
    }

    // Add supporting documents
    if (
      report.data.supporting_documents &&
      report.data.supporting_documents.length > 0
    ) {
      for (const doc of report.data.supporting_documents) {
        // Group by document type
        const docBuffer = await fetchFileAsBuffer(doc.file_url || "");
        if (docBuffer) {
          const folder = doc.document_type || "other";
          zip.file(`documents/supporting/${folder}/${doc.document}`, docBuffer);
        }
      }
    }

    // Add reference attachments
    if (report.data.references && report.data.references.length > 0) {
      for (let i = 0; i < report.data.references.length; i++) {
        const ref = report.data.references[i];
        const refFolder = `documents/references/Reference_${i + 1}_${
          ref.referee_name
        }`;

        // Add reference details as text file
        const refDetails = `
Reference #${i + 1}
================
Referee Name: ${ref.referee_name}
Position: ${ref.referee_role}
Company: ${ref.company_name}
Email: ${ref.referee_email}
Phone: ${ref.referee_phone_number}

Date Received: ${ref.reference_entry.date_received}
Reference Notes: ${ref.reference_entry.notes}

Verification Outcome: ${
          ref.verification_logs[0]?.verification_outcome || "Not verified"
        }
Verification Notes: ${ref.verification_logs[0]?.verification_notes || ""}
Verified By: ${ref.verification_logs[0]?.verified_by || ""}

        `.trim();

        zip.file(`${refFolder}/reference_details.txt`, refDetails);

        // Add reference attachments
        if (
          ref.reference_entry.attachments &&
          ref.reference_entry.attachments.length > 0
        ) {
          for (const attachment of ref.reference_entry.attachments) {
            const attachBuffer = await fetchFileAsBuffer(attachment.url);
            if (attachBuffer) {
              zip.file(`${refFolder}/${attachment.file}`, attachBuffer);
            }
          }
        }
      }
    }

    // Add employment history summary
    const empHistory = report.data.employment_histories
      .map(
        (emp, idx) => `
${idx + 1}. ${emp.company_name}
   Role: ${emp.role}
   Start Date: ${emp.start_date}
   End Date: ${emp.end_date || "Present"}
   Verification Status: ${emp.verification_status}
   Gap Explanation: ${emp.gap_explanation || "None"}
      `
      )
      .join("\n");

    zip.file(
      `documents/employment_history.txt`,
      `EMPLOYMENT HISTORY\n==================\n${empHistory}`
    );

    // Add DBS information
    if (report.data.dbs_information) {
      const dbs = report.data.dbs_information;
      const dbsInfo = `
DBS CHECK INFORMATION
====================
Certificate Number: ${dbs.certificate_number}
Status: ${dbs.status}
Is Valid: ${dbs.is_valid}
Result Status: ${dbs.result.status}
Name: ${dbs.result.first_name} ${dbs.result.last_name}
Data Generated: ${dbs.result.data_generated}
Reviewed By: ${dbs.reviewed_by}
Reviewed At: ${dbs.reviewed_at}
      `.trim();

      zip.file(`documents/dbs_information.txt`, dbsInfo);
    }

    // Add metadata file
    const metadata = `
COMPLIANCE REPORT METADATA
==========================
Report ID: ${report.data.id}
Employee: ${profileData.user_full_name}
Verification Status: ${report.data.verification_status}
Employee Type: ${report.data.employee_type}
Generated: ${new Date().toLocaleString()}

Employment Reviewed: ${report.data.is_employment_reviewed ? "Yes" : "No"}
Employment History Verified: ${
      report.data.is_employment_history_verified ? "Yes" : "No"
    }

COMPLETED CHECKS:
${report.data.checks.map((c) => `- ${c.name}: ${c.description}`).join("\n")}

TODO ITEMS COMPLETED:
${report.data.todo_items.map((t) => `- ${t.task_type}: ${t.status}`).join("\n")}
    `.trim();

    zip.file("METADATA.txt", metadata);

    // Generate ZIP
    const zipBlob = await zip.generateAsync({ type: "blob" });

    return new Response(zipBlob, {
      headers: {
        "Content-Type": "application/zip",
        "Content-Disposition": `attachment; filename="${
          profileData.user_full_name
        }_compliance_report_${new Date().getTime()}.zip"`,
      },
    });
  } catch (error) {
    console.error("[v0] Error generating download:", error);
    return new Response(
      JSON.stringify({
        error: "Error generating download",
        details: String(error),
      }),
      {
        status: 500,
        headers: { "Content-Type": "application/json" },
      }
    );
  }
}
